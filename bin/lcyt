#!/usr/bin/env node

import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import readline from 'readline';
import { YoutubeLiveCaptionSender } from '../src/sender.js';
import { loadConfig, saveConfig, buildIngestionUrl, getDefaultConfigPath } from '../src/config.js';
import logger from '../src/logger.js';

// Detect if running via npx
function isRunningViaNpx() {
  const npmExecPath = process.env.npm_execpath || '';
  const npmCommand = process.env.npm_command || '';
  const npmLifecycleEvent = process.env.npm_lifecycle_event || '';

  return npmExecPath.includes('npx') ||
         npmCommand === 'exec' ||
         npmLifecycleEvent === 'npx';
}

const argv = yargs(hideBin(process.argv))
  .usage('Usage: $0 [options] [caption text]')
  .option('stream-key', {
    alias: 'k',
    type: 'string',
    description: 'YouTube stream key (cid value). When provided alone, saves and enters interactive mode.'
  })
  .option('base-url', {
    alias: 'u',
    type: 'string',
    description: 'Base ingestion URL (default: http://upload.youtube.com/closedcaption)'
  })
  .option('region', {
    alias: 'r',
    type: 'string',
    description: 'Region identifier (default: reg1)'
  })
  .option('cue', {
    type: 'string',
    description: 'Cue identifier (default: cue1)'
  })
  .option('use-region', {
    type: 'boolean',
    description: 'Include region/cue in caption body (format: "TIMESTAMP region:reg1#cue1")',
    default: false
  })
  .option('interactive', {
    alias: 'i',
    type: 'boolean',
    description: 'Interactive mode (read from stdin)',
    default: false
  })
  .option('script-mode', {
    alias: 's',
    type: 'boolean',
    description: 'Script mode: disable automatic interactive mode (for CI/scripts)',
    default: false
  })
  .option('show-config', {
    type: 'boolean',
    description: 'Show current configuration',
    default: false
  })
  .option('heartbeat', {
    type: 'boolean',
    description: 'Send a heartbeat to verify connection',
    default: false
  })
  .option('test', {
    type: 'boolean',
    description: 'Send test payload from Google docs',
    default: false
  })
  .option('timestamp', {
    alias: 't',
    type: 'string',
    description: 'Manual ISO timestamp override'
  })
  .option('reset', {
    type: 'boolean',
    description: 'Reset sequence counter to 0',
    default: false
  })
  .option('config', {
    alias: 'c',
    type: 'string',
    description: 'Config file path'
  })
  .option('verbose', {
    alias: 'v',
    type: 'boolean',
    description: 'Enable verbose output',
    default: false
  })
  .example('$0', 'Setup wizard (first run) or interactive mode (after setup)')
  .example('$0 --stream-key=YOUR_KEY', 'Set stream key and enter interactive mode')
  .example('$0 "Hello world"', 'Send a single caption')
  .example('$0 -i', 'Start interactive mode')
  .example('$0 --heartbeat', 'Send heartbeat to verify connection')
  .example('$0 --show-config', 'Display current configuration')
  .help('help')
  .alias('help', 'h')
  .version()
  .argv;

async function main() {
  const configPath = argv.config || getDefaultConfigPath();

  if (argv.verbose) {
    logger.setVerbose(true);
  }

  let config = loadConfig(configPath);
  let configChanged = false;

  // Track if stream key was provided via argument
  const streamKeyProvided = argv['stream-key'] !== undefined;

  if (streamKeyProvided) {
    config.streamKey = argv['stream-key'];
    configChanged = true;
  }

  if (argv['base-url'] !== undefined) {
    config.baseUrl = argv['base-url'];
    configChanged = true;
  }

  if (argv.region !== undefined) {
    config.region = argv.region;
    configChanged = true;
  }

  if (argv.cue !== undefined) {
    config.cue = argv.cue;
    configChanged = true;
  }

  if (argv.reset) {
    config.sequence = 0;
    configChanged = true;
    logger.info('Sequence counter reset to 0');
  }

  if (configChanged) {
    saveConfig(configPath, config);
    logger.info(`Configuration saved to ${configPath}`);
  }

  const captionText = argv._.join(' ');
  const hasCaption = captionText.length > 0;
  const isInteractive = argv.interactive;
  const isHeartbeat = argv.heartbeat;
  const isTest = argv.test;
  const showConfig = argv['show-config'];
  const scriptMode = argv['script-mode'];

  // Detect first run (no stream key configured)
  const isFirstRun = !config.streamKey;

  // Check if only stream-key was provided (for direct setup flow)
  const onlyStreamKeyProvided = streamKeyProvided && !hasCaption && !isHeartbeat && !isTest && !showConfig;

  // Show config if explicitly requested
  if (showConfig) {
    displayConfig(config, configPath);
    return;
  }

  // Determine if this is a "no action" scenario (no caption, no explicit flags)
  const noActionSpecified = !hasCaption && !isInteractive && !isHeartbeat && !isTest;

  // NEW BEHAVIOR: Default to interactive mode or setup wizard
  if (noActionSpecified && !streamKeyProvided) {
    if (scriptMode) {
      // --no-interactive: show config (old behavior for scripts/CI)
      displayConfig(config, configPath);
      return;
    } else if (isFirstRun) {
      // First run: show setup wizard
      await runSetupWizard(config, configPath);
      return;
    } else {
      // Stream key configured: default to interactive mode
      const ingestionUrl = buildIngestionUrl(config);
      if (!ingestionUrl) {
        logger.error('No ingestion URL configured. Use --stream-key to set one.');
        process.exit(1);
      }
      const sender = new YoutubeLiveCaptionSender({
        ingestionUrl,
        region: config.region,
        cue: config.cue,
        useRegion: argv['use-region'],
        sequence: config.sequence,
        verbose: argv.verbose
      });
      sender.start();
      await runInteractiveMode(sender, config, configPath, argv.timestamp);
      return;
    }
  }

  // Direct setup: stream-key provided alone
  if (onlyStreamKeyProvided) {
    console.log('\n✓ Stream key saved!\n');
    if (scriptMode) {
      // Script mode: just save and exit (config already saved above)
      return;
    }
    // Normal mode: enter interactive mode
    const ingestionUrl = buildIngestionUrl(config);
    const sender = new YoutubeLiveCaptionSender({
      ingestionUrl,
      region: config.region,
      cue: config.cue,
      useRegion: argv['use-region'],
      sequence: config.sequence,
      verbose: argv.verbose
    });
    sender.start();
    await runInteractiveMode(sender, config, configPath, argv.timestamp);
    return;
  }

  const ingestionUrl = buildIngestionUrl(config);

  if (!ingestionUrl) {
    logger.error('No ingestion URL configured. Use --stream-key to set one.');
    process.exit(1);
  }

  const sender = new YoutubeLiveCaptionSender({
    ingestionUrl,
    region: config.region,
    cue: config.cue,
    useRegion: argv['use-region'],
    sequence: config.sequence,
    verbose: argv.verbose
  });

  sender.start();

  if (isTest) {
    await sendTest(sender);
  } else if (isHeartbeat) {
    await sendHeartbeat(sender);
  } else if (isInteractive) {
    await runInteractiveMode(sender, config, configPath, argv.timestamp);
  } else {
    await sendSingleCaption(sender, captionText, config, configPath, argv.timestamp);
  }
}

async function sendTest(sender) {
  try {
    const result = await sender.sendTest();
    logger.info(`Test result: ${result.statusCode}`);
    sender.end();
  } catch (err) {
    logger.error(err.message);
    sender.end();
    process.exit(1);
  }
}

function displayConfig(config, configPath) {
  console.log('\n╔══════════════════════════════════════════════════════════════╗');
  console.log('║                    LCYT Configuration                        ║');
  console.log('╠══════════════════════════════════════════════════════════════╣');
  console.log(`║  Config file: ${configPath.padEnd(45)}║`);
  console.log('╠══════════════════════════════════════════════════════════════╣');
  console.log(`║  Stream Key:  ${(config.streamKey || '(not set)').padEnd(45)}║`);
  console.log(`║  Base URL:    ${(config.baseUrl || '(default)').padEnd(45)}║`);
  console.log(`║  Region:      ${(config.region || 'reg1').padEnd(45)}║`);
  console.log(`║  Cue:         ${(config.cue || 'cue1').padEnd(45)}║`);
  console.log(`║  Sequence:    ${String(config.sequence).padEnd(45)}║`);
  console.log('╠══════════════════════════════════════════════════════════════╣');

  const fullUrl = buildIngestionUrl(config);
  if (fullUrl) {
    console.log(`║  Full URL:    ${fullUrl.substring(0, 45).padEnd(45)}║`);
    if (fullUrl.length > 45) {
      console.log(`║               ${fullUrl.substring(45, 90).padEnd(45)}║`);
    }
  } else {
    console.log('║  Full URL:    (set stream key to generate)                  ║');
  }
  console.log('╚══════════════════════════════════════════════════════════════╝\n');

  console.log('Usage:');
  console.log('  lcyt                         Interactive mode (default)');
  console.log('  lcyt --stream-key "KEY"      Set stream key and enter interactive mode');
  console.log('  lcyt "Your caption text"     Send a single caption');
  console.log('  lcyt --heartbeat             Send heartbeat to verify connection');
  console.log('  lcyt --show-config           Show this configuration');
  console.log('  lcyt --help                  Show all options\n');
}

function showWelcomeBanner() {
  const viaNpx = isRunningViaNpx();

  console.log('\n┌──────────────────────────────────────────────────────────────┐');
  console.log('│            LCYT - Live Captions for YouTube                  │');
  console.log('│         Send real-time captions to your live stream         │');
  console.log('└──────────────────────────────────────────────────────────────┘\n');

  if (viaNpx) {
    console.log('Running via npx. For faster startup, install globally:');
    console.log('  npm install -g lcyt\n');
  }
}

function question(rl, prompt) {
  return new Promise((resolve) => {
    rl.question(prompt, (answer) => {
      resolve(answer.trim());
    });
  });
}

async function runSetupWizard(config, configPath) {
  showWelcomeBanner();
  console.log('First-time setup required.\n');
  console.log('To get your YouTube stream key:');
  console.log('  1. Go to YouTube Studio (studio.youtube.com)');
  console.log('  2. Click Create > Go Live');
  console.log('  3. In stream settings, find "Closed captions"');
  console.log('  4. Enable "POST captions to URL"');
  console.log('  5. Copy the stream key (cid value)\n');

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  try {
    const streamKey = await question(rl, 'Enter your YouTube stream key: ');

    if (!streamKey) {
      console.log('\nNo stream key provided. Setup cancelled.');
      console.log('Run again with: lcyt --stream-key=YOUR_KEY\n');
      rl.close();
      return;
    }

    // Basic validation
    if (streamKey.length < 4) {
      console.log('\nWarning: Stream key seems too short. Proceeding anyway...');
    }

    config.streamKey = streamKey;
    saveConfig(configPath, config);
    console.log('\n✓ Configuration saved!\n');

    // Offer to test connection
    const testConnection = await question(rl, 'Test connection with heartbeat? (Y/n): ');

    if (testConnection.toLowerCase() !== 'n') {
      console.log('\nSending heartbeat...');
      const ingestionUrl = buildIngestionUrl(config);
      const sender = new YoutubeLiveCaptionSender({
        ingestionUrl,
        region: config.region,
        cue: config.cue,
        sequence: config.sequence,
        verbose: false
      });
      sender.start();

      try {
        const result = await sender.heartbeat();
        if (result.serverTimestamp) {
          console.log(`✓ Connection successful! Server time: ${result.serverTimestamp}\n`);
        } else {
          console.log('✓ Connection successful!\n');
        }
        sender.end();
      } catch (err) {
        console.log(`✗ Connection failed: ${err.message}`);
        console.log('  Make sure your stream is live and accepting captions.\n');
        sender.end();
      }
    }

    // Ask if user wants to enter interactive mode
    const enterInteractive = await question(rl, 'Enter interactive mode now? (Y/n): ');
    rl.close();

    if (enterInteractive.toLowerCase() !== 'n') {
      const ingestionUrl = buildIngestionUrl(config);
      const sender = new YoutubeLiveCaptionSender({
        ingestionUrl,
        region: config.region,
        cue: config.cue,
        sequence: config.sequence,
        verbose: argv.verbose
      });
      sender.start();
      await runInteractiveMode(sender, config, configPath, argv.timestamp);
    } else {
      console.log('\nSetup complete! Run lcyt to start sending captions.\n');
    }
  } catch (err) {
    rl.close();
    throw err;
  }
}

async function sendHeartbeat(sender) {
  try {
    const result = await sender.heartbeat();
    if (result.serverTimestamp) {
      logger.info(`Server timestamp: ${result.serverTimestamp}`);
    }
    sender.end();
  } catch (err) {
    logger.error(err.message);
    sender.end();
    process.exit(1);
  }
}

async function sendSingleCaption(sender, text, config, configPath, timestamp) {
  try {
    await sender.send(text, timestamp);
    config.sequence = sender.getSequence();
    saveConfig(configPath, config);
    sender.end();
  } catch (err) {
    logger.error(err.message);
    sender.end();
    process.exit(1);
  }
}

async function runInteractiveMode(sender, config, configPath, defaultTimestamp) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  let batchMode = false;
  let batchCaptions = [];

  console.log('\n╔══════════════════════════════════════════════════════════════╗');
  console.log('║              LCYT Interactive Mode                           ║');
  console.log('╠══════════════════════════════════════════════════════════════╣');
  console.log('║  Commands:                                                   ║');
  console.log('║    <text>              Send single caption                   ║');
  console.log('║    timestamp|text      Send with custom timestamp            ║');
  console.log('║    /batch              Start batch mode (collect captions)   ║');
  console.log('║    /send               Send collected batch                  ║');
  console.log('║    <empty line>        Send batch (if any captions queued)   ║');
  console.log('║    /heartbeat          Send heartbeat                        ║');
  console.log('║    /status             Show current status                   ║');
  console.log('║    Ctrl+C              Exit                                  ║');
  console.log('╚══════════════════════════════════════════════════════════════╝\n');

  rl.setPrompt('caption> ');
  rl.prompt();

  rl.on('line', async (line) => {
    const trimmed = line.trim();
    if (!trimmed) {
      // Empty line sends the batch if one exists
      if (batchCaptions.length > 0) {
        try {
          await sender.sendBatch(batchCaptions);
          config.sequence = sender.getSequence();
          logger.info(`Batch of ${batchCaptions.length} captions sent.`);
        } catch (err) {
          logger.error(err.message);
        }
        batchMode = false;
        batchCaptions = [];
        rl.setPrompt('caption> ');
      }
      rl.prompt();
      return;
    }

    // Handle commands
    if (trimmed.startsWith('/')) {
      const cmd = trimmed.toLowerCase();

      if (cmd === '/batch') {
        batchMode = true;
        batchCaptions = [];
        console.log('Batch mode started. Enter captions, then /send to send all.');
        rl.setPrompt('batch> ');
        rl.prompt();
        return;
      }

      if (cmd === '/send') {
        if (batchCaptions.length === 0) {
          logger.warn('No captions in batch to send.');
        } else {
          try {
            await sender.sendBatch(batchCaptions);
            config.sequence = sender.getSequence();
            logger.info(`Batch of ${batchCaptions.length} captions sent.`);
          } catch (err) {
            logger.error(err.message);
          }
        }
        batchMode = false;
        batchCaptions = [];
        rl.setPrompt('caption> ');
        rl.prompt();
        return;
      }

      if (cmd === '/heartbeat') {
        try {
          const result = await sender.heartbeat();
          if (result.serverTimestamp) {
            logger.info(`Server timestamp: ${result.serverTimestamp}`);
          }
        } catch (err) {
          logger.error(err.message);
        }
        rl.prompt();
        return;
      }

      if (cmd === '/status') {
        console.log(`  Sequence: ${sender.getSequence()}`);
        console.log(`  Batch mode: ${batchMode ? 'ON' : 'OFF'}`);
        if (batchMode) {
          console.log(`  Captions in batch: ${batchCaptions.length}`);
        }
        rl.prompt();
        return;
      }

      logger.warn(`Unknown command: ${trimmed}`);
      rl.prompt();
      return;
    }

    // Parse caption (with optional timestamp)
    let text = trimmed;
    let timestamp = defaultTimestamp;

    if (trimmed.includes('|')) {
      const parts = trimmed.split('|');
      timestamp = parts[0].trim();
      text = parts.slice(1).join('|').trim();
    }

    if (batchMode) {
      batchCaptions.push({ text, timestamp });
      console.log(`  Added to batch (${batchCaptions.length} total)`);
    } else {
      try {
        await sender.send(text, timestamp);
        config.sequence = sender.getSequence();
      } catch (err) {
        logger.error(err.message);
      }
    }

    rl.prompt();
  });

  rl.on('close', () => {
    saveConfig(configPath, config);
    sender.end();
    console.log('\nGoodbye!');
    process.exit(0);
  });

  process.on('SIGINT', () => {
    rl.close();
  });
}

main().catch((err) => {
  logger.error(err.message);
  process.exit(1);
});
