#!/usr/bin/env node

import { readFileSync } from 'fs';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';
import readline from 'readline';
import { YoutubeLiveCaptionSender } from 'lcyt';
import { loadConfig, saveConfig, buildIngestionUrl, getDefaultConfigPath } from 'lcyt/config';
import logger from 'lcyt/logger';
import { InteractiveUI } from '../src/interactive-ui.js';

const __dirname = dirname(fileURLToPath(import.meta.url));
const pkg = JSON.parse(readFileSync(join(__dirname, '..', 'package.json'), 'utf8'));

// Detect if running via npx
function isRunningViaNpx() {
  const npmExecPath = process.env.npm_execpath || '';
  const npmCommand = process.env.npm_command || '';
  const npmLifecycleEvent = process.env.npm_lifecycle_event || '';

  return npmExecPath.includes('npx') ||
         npmCommand === 'exec' ||
         npmLifecycleEvent === 'npx';
}

const argv = yargs(hideBin(process.argv))
  .usage('Usage: $0 [options] [caption text]')
  .option('stream-key', {
    alias: 'k',
    type: 'string',
    description: 'YouTube stream key (cid value)'
  })
  .option('base-url', {
    alias: 'u',
    type: 'string',
    description: 'Base ingestion URL (default: http://upload.youtube.com/closedcaption)'
  })
  .option('region', {
    alias: 'r',
    type: 'string',
    description: 'Region identifier (default: reg1)'
  })
  .option('cue', {
    type: 'string',
    description: 'Cue identifier (default: cue1)'
  })
  .option('use-region', {
    type: 'boolean',
    description: 'Include region/cue in caption body (format: "TIMESTAMP region:reg1#cue1")',
    default: false
  })
  .option('interactive', {
    alias: 'i',
    type: 'boolean',
    description: 'Interactive mode (read from stdin)',
    default: false
  })
  .option('fullscreen', {
    alias: 'f',
    type: 'boolean',
    description: 'Full-screen interactive mode with file loading',
    default: false
  })
  .option('show-config', {
    type: 'boolean',
    description: 'Show current configuration',
    default: false
  })
  .option('heartbeat', {
    type: 'boolean',
    description: 'Send a heartbeat to verify connection',
    default: false
  })
  .option('test', {
    type: 'boolean',
    description: 'Send test payload from Google docs',
    default: false
  })
  .option('batch', {
    alias: 'b',
    type: 'boolean',
    description: 'Add caption to batch queue (stored in config, send with --send)',
    default: false
  })
  .option('send', {
    type: 'boolean',
    description: 'Send all queued batch captions and clear the queue',
    default: false
  })
  .option('timestamp', {
    alias: 't',
    type: 'string',
    description: 'Manual ISO timestamp override'
  })
  .option('reset', {
    type: 'boolean',
    description: 'Reset sequence counter to 0',
    default: false
  })
  .option('config', {
    alias: 'c',
    type: 'string',
    description: 'Config file path'
  })
  .option('verbose', {
    alias: 'v',
    type: 'boolean',
    description: 'Enable verbose output',
    default: false
  })
  .example('$0', 'Show config (or setup wizard on first run)')
  .example('$0 --stream-key=YOUR_KEY', 'Set stream key')
  .example('$0 "Hello world"', 'Send a single caption')
  .example('$0 -i', 'Start interactive mode')
  .example('$0 -f', 'Start full-screen interactive mode')
  .example('$0 --heartbeat', 'Send heartbeat to verify connection')
  .example('$0 -b "Hello world"', 'Add caption to batch queue')
  .example('$0 -b "Line 2" -t "2024-01-15T12:00:00.000"', 'Batch with timestamp')
  .example('$0 --send', 'Send all queued batch captions')
  .help('help')
  .alias('help', 'h')
  .version(pkg.version)
  .argv;

async function main() {
  const configPath = argv.config || getDefaultConfigPath();

  if (argv.verbose) {
    logger.setVerbose(true);
  }

  let config = loadConfig(configPath);
  let configChanged = false;

  // Track if stream key was provided via argument
  const streamKeyProvided = argv['stream-key'] !== undefined;

  if (streamKeyProvided) {
    config.streamKey = argv['stream-key'];
    configChanged = true;
  }

  if (argv['base-url'] !== undefined) {
    config.baseUrl = argv['base-url'];
    configChanged = true;
  }

  if (argv.region !== undefined) {
    config.region = argv.region;
    configChanged = true;
  }

  if (argv.cue !== undefined) {
    config.cue = argv.cue;
    configChanged = true;
  }

  if (argv.reset) {
    config.sequence = 0;
    configChanged = true;
    logger.info('Sequence counter reset to 0');
  }

  if (configChanged) {
    saveConfig(configPath, config);
    logger.info(`Configuration saved to ${configPath}`);
  }

  const captionText = argv._.join(' ');
  const hasCaption = captionText.length > 0;
  const isInteractive = argv.interactive;
  const isFullscreen = argv.fullscreen;
  const isHeartbeat = argv.heartbeat;
  const isTest = argv.test;
  const isBatch = argv.batch;
  const isSend = argv.send;
  const showConfig = argv['show-config'];

  // Detect first run (no stream key configured)
  const isFirstRun = !config.streamKey;

  // Show config if explicitly requested
  if (showConfig) {
    displayConfig(config, configPath);
    return;
  }

  // Handle --batch: queue caption for later sending
  if (isBatch) {
    if (!hasCaption) {
      logger.error('No caption text provided. Usage: lcyt --batch "Your caption"');
      process.exit(1);
    }

    if (!config.batchQueue) {
      config.batchQueue = [];
    }

    const timestamp = argv.timestamp || new Date().toISOString();
    config.batchQueue.push({ text: captionText, timestamp });
    saveConfig(configPath, config);
    logger.info(`Added to batch queue (${config.batchQueue.length} total): "${captionText}"`);
    return;
  }

  // Handle --send: send all queued batch captions
  if (isSend) {
    if (!config.batchQueue || config.batchQueue.length === 0) {
      logger.warn('No captions in batch queue. Use --batch "text" to add captions first.');
      return;
    }

    const ingestionUrl = buildIngestionUrl(config);
    if (!ingestionUrl) {
      logger.error('No ingestion URL configured. Use --stream-key to set one.');
      process.exit(1);
    }

    const sender = new YoutubeLiveCaptionSender({
      ingestionUrl,
      region: config.region,
      cue: config.cue,
      useRegion: argv['use-region'],
      sequence: config.sequence,
      verbose: argv.verbose
    });

    sender.start();

    try {
      const count = config.batchQueue.length;
      await sender.sendBatch(config.batchQueue);
      config.sequence = sender.getSequence();
      config.batchQueue = [];
      saveConfig(configPath, config);
      logger.info(`Batch of ${count} caption(s) sent successfully.`);
      sender.end();
    } catch (err) {
      logger.error(err.message);
      sender.end();
      process.exit(1);
    }
    return;
  }

  // Determine if this is a "no action" scenario (no caption, no explicit flags)
  const noActionSpecified = !hasCaption && !isInteractive && !isFullscreen && !isHeartbeat && !isTest;

  // Default behavior: show config or setup wizard (pipeline-friendly)
  if (noActionSpecified) {
    if (isFirstRun && !streamKeyProvided) {
      // First run with no stream key: show setup wizard
      await runSetupWizard(config, configPath);
      return;
    } else if (isRunningViaNpx()) {
      // Running via npx with no action specified: default to fullscreen mode
      const ingestionUrl = buildIngestionUrl(config);
      if (!ingestionUrl) {
        logger.error('No ingestion URL configured. Use --stream-key to set one.');
        process.exit(1);
      }

      const sender = new YoutubeLiveCaptionSender({
        ingestionUrl,
        region: config.region,
        cue: config.cue,
        useRegion: argv['use-region'],
        sequence: config.sequence,
        verbose: argv.verbose
      });

      sender.start();
      await runFullscreenMode(sender, config, configPath, argv.timestamp);
      return;
    } else {
      // Show config (default non-interactive behavior)
      displayConfig(config, configPath);
      return;
    }
  }

  const ingestionUrl = buildIngestionUrl(config);

  if (!ingestionUrl) {
    logger.error('No ingestion URL configured. Use --stream-key to set one.');
    process.exit(1);
  }

  const sender = new YoutubeLiveCaptionSender({
    ingestionUrl,
    region: config.region,
    cue: config.cue,
    useRegion: argv['use-region'],
    sequence: config.sequence,
    verbose: argv.verbose
  });

  sender.start();

  if (isTest) {
    await sendTest(sender);
  } else if (isHeartbeat) {
    await sendHeartbeat(sender);
  } else if (isFullscreen) {
    await runFullscreenMode(sender, config, configPath, argv.timestamp);
  } else if (isInteractive) {
    await runInteractiveMode(sender, config, configPath, argv.timestamp);
  } else {
    await sendSingleCaption(sender, captionText, config, configPath, argv.timestamp);
  }
}

async function sendTest(sender) {
  try {
    const result = await sender.sendTest();
    logger.info(`Test result: ${result.statusCode}`);
    sender.end();
  } catch (err) {
    logger.error(err.message);
    sender.end();
    process.exit(1);
  }
}

function displayConfig(config, configPath) {
  const width = 74; // Total line width including borders
  const contentWidth = 57; // Width for padded content (74 - 2 borders - 2 spaces - 13 for label)

  const border = '═'.repeat(width - 2);

  console.log(`\n╔${border}╗`);
  console.log(`║${'LCYT Configuration'.padStart(37).padEnd(width - 2)}║`);
  console.log(`╠${border}╣`);
  console.log(`║  Config file: ${configPath.padEnd(contentWidth)}║`);
  console.log(`╠${border}╣`);
  console.log(`║  Stream Key:  ${(config.streamKey || '(not set)').padEnd(contentWidth)}║`);
  console.log(`║  Base URL:    ${(config.baseUrl || '(default)').padEnd(contentWidth)}║`);
  console.log(`║  Region:      ${(config.region || 'reg1').padEnd(contentWidth)}║`);
  console.log(`║  Cue:         ${(config.cue || 'cue1').padEnd(contentWidth)}║`);
  console.log(`║  Sequence:    ${String(config.sequence).padEnd(contentWidth)}║`);
  console.log(`╠${border}╣`);

  const fullUrl = buildIngestionUrl(config);
  if (fullUrl) {
    if (fullUrl.length <= contentWidth) {
      console.log(`║  Full URL:    ${fullUrl.padEnd(contentWidth)}║`);
    } else {
      // Split long URL across multiple lines
      console.log(`║  Full URL:    ${fullUrl.substring(0, contentWidth)}║`);
      let remaining = fullUrl.substring(contentWidth);
      while (remaining.length > 0) {
        console.log(`║               ${remaining.substring(0, contentWidth).padEnd(contentWidth)}║`);
        remaining = remaining.substring(contentWidth);
      }
    }
  } else {
    console.log(`║  Full URL:    ${'(set stream key to generate)'.padEnd(contentWidth)}║`);
  }
  console.log(`╚${border}╝\n`);

  console.log('Usage:');
  console.log('  lcyt --stream-key "KEY"      Set your YouTube stream key');
  console.log('  lcyt "Your caption text"     Send a single caption');
  console.log('  lcyt -i                      Start interactive mode');
  console.log('  lcyt -f                      Start full-screen interactive mode');
  console.log('  lcyt --heartbeat             Send heartbeat to verify connection');
  console.log('  lcyt --help                  Show all options\n');
}

function showWelcomeBanner() {
  const viaNpx = isRunningViaNpx();

  console.log('\n┌──────────────────────────────────────────────────────────────┐');
  console.log('│            LCYT - Live Captions for YouTube                  │');
  console.log('│         Send real-time captions to your live stream         │');
  console.log('└──────────────────────────────────────────────────────────────┘\n');

  if (viaNpx) {
    console.log('Running via npx.');
    console.log('  • npx lcyt-cli    - Launches full-screen mode (default)');
    console.log('  • npx lcyt-cli -i - Use standard interactive mode');
    console.log('\nFor faster startup, install globally:');
    console.log('  npm install -g lcyt-cli\n');
  }
}

function question(rl, prompt) {
  return new Promise((resolve) => {
    rl.question(prompt, (answer) => {
      resolve(answer.trim());
    });
  });
}

async function runSetupWizard(config, configPath) {
  showWelcomeBanner();
  console.log('First-time setup required.\n');
  console.log('To get your YouTube stream key:');
  console.log('  1. Go to YouTube Studio (studio.youtube.com)');
  console.log('  2. Click Create > Go Live');
  console.log('  3. In stream settings, find "Closed captions"');
  console.log('  4. Enable "POST captions to URL"');
  console.log('  5. Copy the stream key (cid value)\n');

  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  try {
    const streamKey = await question(rl, 'Enter your YouTube stream key: ');

    if (!streamKey) {
      console.log('\nNo stream key provided. Setup cancelled.');
      console.log('Run again with: lcyt --stream-key=YOUR_KEY\n');
      rl.close();
      return;
    }

    // Basic validation
    if (streamKey.length < 4) {
      console.log('\nWarning: Stream key seems too short. Proceeding anyway...');
    }

    config.streamKey = streamKey;
    saveConfig(configPath, config);
    console.log('\n✓ Configuration saved!\n');

    // Offer to test connection
    const testConnection = await question(rl, 'Test connection with heartbeat? (Y/n): ');

    if (testConnection.toLowerCase() !== 'n') {
      console.log('\nSending heartbeat...');
      const ingestionUrl = buildIngestionUrl(config);
      const sender = new YoutubeLiveCaptionSender({
        ingestionUrl,
        region: config.region,
        cue: config.cue,
        sequence: config.sequence,
        verbose: false
      });
      sender.start();

      try {
        const result = await sender.heartbeat();
        if (result.serverTimestamp) {
          console.log(`✓ Connection successful! Server time: ${result.serverTimestamp}\n`);
        } else {
          console.log('✓ Connection successful!\n');
        }
        sender.end();
      } catch (err) {
        console.log(`✗ Connection failed: ${err.message}`);
        console.log('  Make sure your stream is live and accepting captions.\n');
        sender.end();
      }
    }

    rl.close();
    console.log('Setup complete! You can now use lcyt:\n');
    console.log('  lcyt "Your caption"    Send a caption');
    console.log('  lcyt -i                Interactive mode');
    console.log('  lcyt --heartbeat       Test connection\n');
  } catch (err) {
    rl.close();
    throw err;
  }
}

async function sendHeartbeat(sender) {
  try {
    const result = await sender.heartbeat();
    if (result.serverTimestamp) {
      logger.info(`Server timestamp: ${result.serverTimestamp}`);
    }
    sender.end();
  } catch (err) {
    logger.error(err.message);
    sender.end();
    process.exit(1);
  }
}

async function sendSingleCaption(sender, text, config, configPath, timestamp) {
  try {
    await sender.send(text, timestamp);
    config.sequence = sender.getSequence();
    saveConfig(configPath, config);
    sender.end();
  } catch (err) {
    logger.error(err.message);
    sender.end();
    process.exit(1);
  }
}

async function runInteractiveMode(sender, config, configPath, defaultTimestamp) {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
  });

  let batchMode = false;
  let batchCaptions = [];
  let batchTimeout = 5; // Default 5 seconds
  let batchTimer = null;

  const sendBatch = async () => {
    if (batchCaptions.length > 0) {
      try {
        await sender.sendBatch(batchCaptions);
        config.sequence = sender.getSequence();
        logger.info(`Batch of ${batchCaptions.length} captions sent.`);
      } catch (err) {
        logger.error(err.message);
      }
    }
    // Keep batch mode active, just clear the batch
    batchCaptions = [];
    if (batchTimer) {
      clearTimeout(batchTimer);
      batchTimer = null;
    }
  };

  console.log('\n╔══════════════════════════════════════════════════════════════╗');
  console.log('║              LCYT Interactive Mode                           ║');
  console.log('╠══════════════════════════════════════════════════════════════╣');
  console.log('║  Commands:                                                   ║');
  console.log('║    <text>              Send single caption                   ║');
  console.log('║    timestamp|text      Send with custom timestamp            ║');
  console.log('║    /batch [seconds]    Start auto-batch mode (default: 5s)   ║');
  console.log('║    /send               Send collected batch immediately      ║');
  console.log('║    <empty line>        Send batch (if any captions queued)   ║');
  console.log('║    /heartbeat          Send heartbeat                        ║');
  console.log('║    /status             Show current status                   ║');
  console.log('║    Ctrl+C              Exit                                  ║');
  console.log('╚══════════════════════════════════════════════════════════════╝\n');

  rl.setPrompt('caption> ');
  rl.prompt();

  rl.on('line', async (line) => {
    const trimmed = line.trim();
    if (!trimmed) {
      // Empty line sends the batch if one exists
      if (batchCaptions.length > 0) {
        await sendBatch();
      }
      rl.prompt();
      return;
    }

    // Handle commands
    if (trimmed.startsWith('/')) {
      const cmdParts = trimmed.split(/\s+/);
      const cmd = cmdParts[0].toLowerCase();

      if (cmd === '/batch') {
        // Parse optional timeout parameter
        if (cmdParts.length > 1) {
          const seconds = parseInt(cmdParts[1], 10);
          if (!isNaN(seconds) && seconds > 0) {
            batchTimeout = seconds;
          }
        }

        batchMode = true;
        batchCaptions = [];
        if (batchTimer) {
          clearTimeout(batchTimer);
          batchTimer = null;
        }
        console.log(`Batch mode started. Captions will auto-send after ${batchTimeout} seconds of first caption.`);
        rl.setPrompt('batch> ');
        rl.prompt();
        return;
      }

      if (cmd === '/send') {
        if (batchCaptions.length === 0) {
          logger.warn('No captions in batch to send.');
          batchMode = false;
          rl.setPrompt('caption> ');
        } else {
          await sendBatch();
        }
        rl.prompt();
        return;
      }

      if (cmd === '/heartbeat') {
        try {
          const result = await sender.heartbeat();
          if (result.serverTimestamp) {
            logger.info(`Server timestamp: ${result.serverTimestamp}`);
          }
        } catch (err) {
          logger.error(err.message);
        }
        rl.prompt();
        return;
      }

      if (cmd === '/status') {
        console.log(`  Sequence: ${sender.getSequence()}`);
        console.log(`  Batch mode: ${batchMode ? 'ON' : 'OFF'}`);
        if (batchMode) {
          console.log(`  Captions in batch: ${batchCaptions.length}`);
          console.log(`  Auto-send timeout: ${batchTimeout}s`);
          console.log(`  Timer active: ${batchTimer ? 'YES' : 'NO'}`);
        }
        rl.prompt();
        return;
      }

      logger.warn(`Unknown command: ${trimmed}`);
      rl.prompt();
      return;
    }

    // Parse caption (with optional timestamp)
    let text = trimmed;
    let timestamp = defaultTimestamp;

    if (trimmed.includes('|')) {
      const parts = trimmed.split('|');
      timestamp = parts[0].trim();
      text = parts.slice(1).join('|').trim();
    }

    if (batchMode) {
      batchCaptions.push({ text, timestamp });
      console.log(`  Added to batch (${batchCaptions.length} total)`);

      // Start timer on first caption
      if (batchCaptions.length === 1 && !batchTimer) {
        console.log(`  Timer started: batch will send in ${batchTimeout} seconds`);
        batchTimer = setTimeout(async () => {
          console.log('\n  Auto-sending batch...');
          await sendBatch();
          rl.prompt();
        }, batchTimeout * 1000);
      }
    } else {
      try {
        await sender.send(text, timestamp);
        config.sequence = sender.getSequence();
      } catch (err) {
        logger.error(err.message);
      }
    }

    rl.prompt();
  });

  rl.on('close', () => {
    if (batchTimer) {
      clearTimeout(batchTimer);
    }
    saveConfig(configPath, config);
    sender.end();
    console.log('\nGoodbye!');
    process.exit(0);
  });

  process.on('SIGINT', () => {
    rl.close();
  });
}

async function runFullscreenMode(sender, config, configPath, defaultTimestamp) {
  const ui = new InteractiveUI(sender, config, configPath, defaultTimestamp);
  await ui.start();
}

main().catch((err) => {
  logger.error(err.message);
  process.exit(1);
});
